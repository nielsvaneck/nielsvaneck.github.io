<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>make on niels van eck</title><link>https://nielsvaneck.com/tags/make/</link><description>Recent content in make on niels van eck</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 18 May 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://nielsvaneck.com/tags/make/index.xml" rel="self" type="application/rss+xml"/><item><title>Automating npm install</title><link>https://nielsvaneck.com/post/2021-05-18-automating-npm-install/</link><pubDate>Tue, 18 May 2021 00:00:00 +0000</pubDate><guid>https://nielsvaneck.com/post/2021-05-18-automating-npm-install/</guid><description>I&amp;rsquo;ve previously written about using Make as a command interface for your repository and the other day, I ran into a situation where using Makefiles takes away a real-life annoyance for teams working on NodeJS and other Javascript or TypeScript based projects.
When growing teams work in repositories that use NPM for Yarn for package management, dependency updates will enter the local workspace frequently when the main branch is pulled. Unless you&amp;rsquo;re religious about running npm install after every git pull, updating local dependencies of often omitted and sometimes leads to confusing red herring bugs or in the very least, lost time.</description></item><item><title>Rendering Mermaid graphs in Markdown on GitHub</title><link>https://nielsvaneck.com/post/2021-01-20-rendering-mermaid-graphs-in-markdown-on-github/</link><pubDate>Wed, 20 Jan 2021 08:03:00 -0800</pubDate><guid>https://nielsvaneck.com/post/2021-01-20-rendering-mermaid-graphs-in-markdown-on-github/</guid><description>When writing documentation for software, sooner or later you&amp;rsquo;re going to hit the point at which a picture will explain in a glance what you would have a hard time describing in the proverbial &amp;ldquo;thousand words&amp;rdquo;. While documenting something technical, this usually means diving into the drawing section of whatever editor you&amp;rsquo;re using and wrangling with lines and boxes until you&amp;rsquo;re satisfied with your masterpiece or you&amp;rsquo;ve exhausted your patience with the tool.</description></item><item><title>“Make” as a command interface to your repository</title><link>https://nielsvaneck.com/post/2020-11-21-make-as-a-command-interface-to-your-repository/</link><pubDate>Sat, 21 Nov 2020 00:00:00 +0000</pubDate><guid>https://nielsvaneck.com/post/2020-11-21-make-as-a-command-interface-to-your-repository/</guid><description>Back in 1976, when Make first entered the scene, it solved the problem of automating dependency aware software builds. By defining what sources a build target operates on, it could automatically determine what should be compiled based on what files had changed, thus saving on computing time while guaranteeing correct builds.
Command vs Automatic Targets The ability to define build targets that could be invoked from the command line as make arguments, quickly lead to Make being used for other tasks than just building software, think of make install for example.</description></item></channel></rss>
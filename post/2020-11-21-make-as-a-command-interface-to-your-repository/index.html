<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>‚ÄúMake‚Äù as a command interface to your repository</title><style>html body{font-family:raleway,sans-serif;font-size:16px;background-color:#fff}:root{--accent:#08c;--border-width:0}</style><link rel=stylesheet href=https://nielsvaneck.com/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Raleway"><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/monokai-sublime.min.css><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA==" crossorigin=anonymous><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/sql.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/bash.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/javascript.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/go.min.js></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/makefile.min.js></script><script>hljs.initHighlightingOnLoad()</script><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on('click',function(){$('.collapse').collapse('hide')})</script><meta name=generator content="Hugo 0.83.1"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-48666603-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-48666603-1')</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>‚ÄúMake‚Äù as a command interface to your repository</a>
<button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span><span class=icon-bar></span><span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>Home</a></li><li><a href=/post/>Posts</a></li><li><a href=/about/>About</a></li></ul><ul class="nav navbar-nav navbar-right"><li class=navbar-icon><a href=https://github.com/nielsvaneck/><i class="fab fa-github"></i></a></li><li class=navbar-icon><a href=https://twitter.com/niels/><i class="fab fa-twitter"></i></a></li><li class=navbar-icon><a href=https://www.linkedin.com/in/nielsvaneck/><i class="fab fa-linkedin"></i></a></li><li class=navbar-icon><a href=https://nielsvaneck.com/index.xml><i class="fas fa-rss"></i></a></li></ul></div></div></nav><main><div><h2>‚ÄúMake‚Äù as a command interface to your repository</h2><h5>November 21, 2020</h5><a href=https://nielsvaneck.com/tags/devops><kbd class=item-tag>devops</kbd></a>
<a href=https://nielsvaneck.com/tags/make><kbd class=item-tag>make</kbd></a></div><div align=start class=content><p>Back in 1976, when Make first entered the scene, it solved the problem of automating dependency aware software builds. By defining what sources a build target operates on, it could automatically determine what should be compiled based on what files had changed, thus saving on computing time while guaranteeing correct builds.</p><h2 id=command-vs-automatic-targets>Command vs Automatic Targets</h2><p>The ability to define build targets that could be invoked from the command line as <code>make</code> arguments, quickly lead to Make being used for other tasks than just building software, think of <code>make install</code> for example.</p><p>This &ldquo;extracurricular&rdquo; usage of the Make build tool proves useful to this day. A Makefile at the root of your repository provides a quick way to define commands for; bootstrapping the repository, running code-generation, executing tests, kicking off deployment and last but not least, if your project requires it, building executables. I have been thinking about these targets as &ldquo;commands&rdquo;, they are the main entry points into the functionality of your Makefile.</p><p>A well equipped makefile becomes a command line tool for your repository.</p><p>The beauty of Make is its dependency system. By defining prerequisites <em>(what targets should run before your target, and/or did any of the files-your- target-depends-on change, thus requiring your target to run)</em>, you can ensure for example; that code is built before running tests, or that tests re-execute with updated coverage tracking configuration, before opening the test-coverage report in a browser. Let&rsquo;s call targets in these dependency chains &ldquo;Automatic&rdquo; targets. They are like building blocks. You&rsquo;d rarely execute them individually, but together they enable powerful functionality.</p><p>In recent projects, I&rsquo;ve used Makefiles in this exact way. The Makefile offers a command line interface to the repository. It can be used to:</p><ul><li>bootstrap the repository</li><li>generate code</li><li>run various linters</li><li>run django, both as a server and in shell mode</li><li>run tests, with or without coverage tracking</li><li>open coverage reports in a browser (which of course automatically re-executes tests when necessary)</li><li>build docker containers</li><li>run django shell & server inside the docker container</li><li>run tests inside of the docker container</li><li>deploy</li><li>configure cloud tools to target development, staging or production environments</li><li>forward ports to a kubernetes pod</li><li>etc.</li></ul><p>All that, performed with required prerequisite work, by just running make with a simple argument. It has been a joy to use. But as so often in life, you can&rsquo;t have a silver lining without a cloud. This abundance of functionality in a Makefile brings with it two problems. 1) Silo-ing of potentially re-usable functionality and, 2), poor user experience, due to lack of target discoverability and an epic case of cognitive overload when trying to read through them.</p><h2 id=make-help>Make help</h2><p>Most Makefiles contain a boat load of targets, alphabetically-ish sorted if you&rsquo;re lucky. There is no good way to distinguish command targets from automatic targets, let alone to get a quick idea of what you can do with a Makefile.</p><p>Despite that shortcoming, I still thought it was worth writing about this particular way of Makefile usage. In past employment and projects, I‚Äôve seen countless examples of important commands having to be copied from documentation, and I don‚Äôt know how I would have done my job without relying heavily on bash history. Makefiles with a variety of command targets would have been very valuable to me in those days.</p><p>Then, while doing some research for this post, I came across <a href=https://victoria.dev/blog/how-to-create-a-self-documenting-makefile/>how to create a self-documenting Makefile</a>, by <a href=https://victoria.dev/>Victoria Drake</a>. In that article, she not only outlines my repository command line tool use-case for Makefiles, it goes on to introduce the exact thing I had missed in my Makefiles, a quick way to get an overview of the commands contained within them ü§Ø üéâ.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=color:#a6e22e>.PHONY</span><span style=color:#f92672>:</span> help
<span style=color:#a6e22e>help</span><span style=color:#f92672>:</span> <span style=color:#75715e>## Show this help
</span><span style=color:#75715e></span>	@egrep -h <span style=color:#e6db74>&#39;\s##\s&#39;</span> <span style=color:#66d9ef>$(</span>MAKEFILE_LIST<span style=color:#66d9ef>)</span> | <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>	sort | <span style=color:#ae81ff>\
</span><span style=color:#ae81ff></span>	awk <span style=color:#e6db74>&#39;BEGIN {FS = &#34;:.*?## &#34;}; \
</span><span style=color:#e6db74>		{printf &#34;\033[36m%-20s\033[0m %s\n&#34;, $$1, $$2}&#39;</span>
</code></pre></div><p>Some more Googling revealed that variants of this <code>help</code> target have been presented <a href=https://www.cmcrossroads.com/print/article/self-documenting-makefiles>a</a> <a href=https://gist.github.com/prwhite/8168133>few</a> <a href=https://www.thapaliya.com/en/writings/well-documented-makefiles/>numerous</a> <a href=https://marmelab.com/blog/2016/02/29/auto-documented-makefile.html>times</a> <a href=https://nedbatchelder.com/blog/201804/makefile_help_target.html>over</a> <a href=https://aben20807.github.io/posts/20190402-makefile-help-message/>the</a> <a href=https://stackoverflow.com/questions/8889035/how-to-document-a-makefile>years</a>, ultimately evolving to the version published by Victoria. Here&rsquo;s how it works:</p><ul><li>first it loops over <code>MAKEFILE_LIST</code> (a list of all lines in the makefile that define a target) using <a href="https://www.freebsd.org/cgi/man.cgi?query=egrep&format=html"><code>egrep</code></a>, and retains the lines that have a <code>##</code> comment.</li><li>it then <a href="https://www.freebsd.org/cgi/man.cgi?query=sort&apropos=0&sektion=0&manpath=FreeBSD+12.2-RELEASE+and+Ports&arch=default&format=html"><code>sort</code></a>s the remaining items</li><li>and finally, runs the sorted lines through <a href="https://www.freebsd.org/cgi/man.cgi?query=awk&apropos=0&sektion=0&manpath=FreeBSD+12.2-RELEASE+and+Ports&arch=default&format=html"><code>awk</code></a>`, with a few tricks<ul><li><code>BEGIN {FS = ":.*?## "};</code>
<code>BEGIN</code> denotes a block that is to be executed before any input is processed. This block assigns <code>FS</code>, the <em>Field Separator</em>, to a regular expression that matches everything from the semicolon (which follows the target name), including the prerequisite list to the <code>##</code> that indicates a ‚Äòhelp‚Äô comment. This causes each Makefile target line to be broken up in the target name (<code>$1</code>) and the help comment (<code>$2</code>).</li><li><code>{printf "\033[36m%-20s\033[0m %s\n", $$1, $$2}</code>
this one seems a little tricky at first, as there is a lot going on, but simply put, it uses <a href="https://www.freebsd.org/cgi/man.cgi?query=printf&apropos=0&sektion=0&manpath=FreeBSD+12.2-RELEASE+and+Ports&arch=default&format=html"><code>printf</code></a> to output the target name and the help comment in two columns.
Let‚Äôs break the format string into its parts:<ul><li><code>\033[</code> starts a terminal escape sequence and 36m then sets the text color to ‚Äúlight cyan‚Äù</li><li><code>%-20s</code> will print a string variable, the target name, padded on the right up to a width of 20 characters</li><li><code>\033[</code> starts another escape sequence in which <code>0m</code> resets the text color</li><li><code>%s\n</code> prints the second string variable, the help text, along with a newline character.</li><li><code>$$1</code>, <code>$$2</code> are the first and second parts of the line, target name and help comment as broken up based on the Field Separator rule defined earlier. <code>$$</code> because <code>$</code> needs to be doubled up inside a Makefile.</li></ul></li></ul></li></ul><p>With the <code>help</code> target defined in the Makefile, and &ldquo;command&rdquo; targets annotated with <code>## help text</code> comments, executing <code>make help</code> will now print out a quick overview of what you can do with the Makefile. Brilliant.</p><p>A nice side effect of <code>## help text</code> comments on command targets is that it visually separates them from their &ldquo;automatic&rdquo; siblings when reading through the Makefile.</p><h2 id=makefile-target-re-use>Makefile target re-use</h2><p>When using Makefiles as a command interface for your repository, it will likely contain targets that can be shared with other repositories in your organization or other projects you work on. The <code>help</code> target presented above is a prime example. Most Makefiles are self-contained. Their targets are specific to the repository and project they exist in. But Makefiles can <a href=https://www.gnu.org/software/make/manual/html_node/Include.html>include</a> other Makefiles, which offers a way to bring in common targets.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#960050;background-color:#1e0010>-include</span> <span style=color:#960050;background-color:#1e0010>common.mk</span>
</code></pre></div><p>Makefile includes can live in a different repository, a git submodule, a symlinked directory, etc. The possibilities are endless. The Makefile could even contain bootstrap logic to fetch the included files. If that is the case, ensure the include statements are prefixed with &ldquo;<code>-</code>&rdquo;. This will ignore import errors and allow targets in the Makefile to run without the include files being present, thus preventing a bootstrap / include catch-22 situation.</p><p>Over the past year, I have created Makefiles for various repositories based on the practices outlined above. Shared logic is brought in through git submodules and using make help, command targets are discoverable and documented. As an added bonus, maintaining and improving this toolkit is a great way to &ldquo;get in the zone&rdquo;. I&rsquo;ll be using this wherever appropriate and I hope you will find it useful too. If so, drop me a line!</p><p>-<a href=https://twitter.com/niels>@niels</a></p><p>btw, here are some resources for writing Makefiles I found helpful:</p><ul><li><a href=https://www.gnu.org/software/make/manual/html_node/index.html>GNU Make Manual</a>. There is a *lot* to Make. (though I&rsquo;ve had most luck just searching with Google)</li><li><a href=https://tech.davis-hansson.com/p/make/>Your Makefiles are wrong</a> by <a href=https://tech.davis-hansson.com>Jacob Davis-Hansson</a> which introduced me to the concept of sentinel targets. These targets are named after- and <code>touch</code> a &ldquo;sentinel&rdquo; file when the work is done. This allows targets that don&rsquo;t produce anything or produce multiple files to function in a dependency chain. I use this a *lot* for writing &ldquo;automation&rdquo; targets.</li><li><a href=https://victoria.dev/blog/how-to-create-a-self-documenting-makefile/>How to create a self-documenting Makefile</a>, by <a href=https://victoria.dev/>Victoria Drake</a>. Make help.</li><li><a href=https://github.com/mrtazz/checkmake>Checkmake</a>, a Makefile lint tool, conveniently executable from a <a href=https://github.com/cytopia/docker-checkmake>Docker image</a>, which enables; <code>make lint-make</code>, a self-check for your Makefile üòú</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-makefile data-lang=makefile><span style=color:#a6e22e>.PHONY</span><span style=color:#f92672>:</span> lint-make

<span style=color:#a6e22e>lint-make</span><span style=color:#f92672>:</span> <span style=color:#75715e>## Run Checkmake on Makefile (requires docker)
</span><span style=color:#75715e></span>	@docker run --rm -v <span style=color:#e6db74>&#34;</span>$$<span style=color:#e6db74>(pwd):/data&#34;</span> cytopia/checkmake Makefile
</code></pre></div></div><h4 class=page-header>Related</h4><div class=item><h4><a href=/post/2021-05-18-automating-npm-install/>Automating npm install</a></h4><h5>May 18, 2021</h5><a href=https://nielsvaneck.com/tags/devops><kbd class=item-tag>devops</kbd></a>
<a href=https://nielsvaneck.com/tags/make><kbd class=item-tag>make</kbd></a>
<a href=https://nielsvaneck.com/tags/npm><kbd class=item-tag>npm</kbd></a></div><div class=item><h4><a href=/post/2021-01-20-rendering-mermaid-graphs-in-markdown-on-github/>Rendering Mermaid graphs in Markdown on GitHub</a></h4><h5>January 20, 2021</h5><a href=https://nielsvaneck.com/tags/make><kbd class=item-tag>make</kbd></a>
<a href=https://nielsvaneck.com/tags/mermaid><kbd class=item-tag>mermaid</kbd></a>
<a href=https://nielsvaneck.com/tags/markdown><kbd class=item-tag>markdown</kbd></a>
<a href=https://nielsvaneck.com/tags/github><kbd class=item-tag>github</kbd></a></div></main><footer><p class="copyright text-muted">¬© All rights reserved. Powered by <a href=https://gohugo.io>Hugo</a> and <a href=https://github.com/calintat/minimal>Minimal</a>.</p></footer></body></html>
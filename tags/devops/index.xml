<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>devops on niels van eck</title><link>https://nielsvaneck.com/tags/devops/</link><description>Recent content in devops on niels van eck</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 21 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://nielsvaneck.com/tags/devops/index.xml" rel="self" type="application/rss+xml"/><item><title>“Make” as a command interface to your repository</title><link>https://nielsvaneck.com/post/2020-11-21-make-as-a-command-interface-to-your-repository/</link><pubDate>Sat, 21 Nov 2020 00:00:00 +0000</pubDate><guid>https://nielsvaneck.com/post/2020-11-21-make-as-a-command-interface-to-your-repository/</guid><description>Back in 1976, when Make first entered the scene, it solved the problem of automating dependency aware software builds. By defining what sources a build target operates on, it could automatically determine what should be compiled based on what files had changed, thus saving on computing time while guaranteeing correct builds.
Command vs Automatic Targets The ability to define build targets that could be invoked from the command line as make arguments, quickly lead to Make being used for other tasks than just building software, think of make install for example.</description></item></channel></rss>